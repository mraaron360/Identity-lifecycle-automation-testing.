# Identity Lifecycle Automation (Okta/Azure AD)

Automate **user onboarding, offboarding, and access updates** from HR data into an Identity Provider (IdP). Ships with a fully working **Mock IdP** so you can run end‑to‑end locally, and pluggable clients for **Okta** and **Azure AD** you can flesh out with real API keys.

---

## 📁 Repo Structure

```
identity-lifecycle-automation/
├── README.md
├── requirements.txt
├── .env.example
├── config/
│   └── mappings.yml
├── data/
│   ├── new_hires.csv
│   └── terminations.csv
├── lifecycle/
│   ├── __init__.py
│   ├── cli.py
│   ├── engine.py
│   ├── hr.py
│   ├── mapper.py
│   ├── models.py
│   ├── idp_base.py
│   └── idps/
│       ├── __init__.py
│       ├── mock_idp.py
│       ├── okta_idp.py
│       └── azuread_idp.py
├── state/
│   └── mock_directory.json
├── tests/
│   ├── test_mapper.py
│   └── test_engine.py
└── .github/
    └── workflows/
        └── ci.yml
```

---

## 🚀 Quickstart (Mock IdP)

1. **Clone & create venv**

   ```bash
   git clone <your-repo-url> identity-lifecycle-automation
   cd identity-lifecycle-automation
   python3 -m venv .venv && source .venv/bin/activate
   pip install -r requirements.txt
   ```
2. **Configure env & mappings**

   ```bash
   cp .env.example .env
   # default IDP=mock is fine for local runs
   ```
3. **Dry-run onboarding**

   ```bash
   python -m lifecycle.cli sync \
     --source data/new_hires.csv \
     --mapping config/mappings.yml \
     --idp mock --dry-run
   ```
4. **Apply onboarding**

   ```bash
   python -m lifecycle.cli sync \
     --source data/new_hires.csv \
     --mapping config/mappings.yml \
     --idp mock --apply
   ```
5. **Offboard terminations**

   ```bash
   python -m lifecycle.cli offboard \
     --source data/terminations.csv \
     --idp mock --apply
   ```
6. **Audit**

   ```bash
   python -m lifecycle.cli audit --idp mock
   ```

> ✅ The Mock IdP persists state at `state/mock_directory.json` so you can see users/groups after runs.

---

## 🔧 Switching to Real IdPs

* **Okta**: set `IDP=okta` and populate `OKTA_ORG_URL`, `OKTA_API_TOKEN` in `.env`. Implement API calls in `lifecycle/idps/okta_idp.py` (skeleton provided with retry/backoff).
* **Azure AD**: set `IDP=azuread` and populate `AZURE_TENANT_ID`, `AZURE_CLIENT_ID`, `AZURE_CLIENT_SECRET`. Implement calls in `lifecycle/idps/azuread_idp.py`.

Keep `--dry-run` on until you’re confident, then use `--apply`.

---

## 🧠 Features

* Idempotent create/update of users (no dupes)
* Group & role mapping from HR attributes (dept/title/location)
* Offboarding (disable & deprovision)
* CSV HR sources (API/DB hooks ready)
* Audit report highlighting drift
* Logging + retry/backoff guidance for real IdPs
* CI: lint + tests via GitHub Actions

---

## 🏗️ Architecture (High-Level)

```
HR (CSV/API) ──> hr.py ──> models.User ──> engine.sync
                               │           ├─> mapper.map(user)
                               │           └─> idp.ensure_user / set_groups / deactivate
IdP (Mock/Okta/Azure) <──────── idp_* clients
```

---

## 🧩 Files & Code

### requirements.txt

```txt
python-dotenv==1.0.1
PyYAML==6.0.2
requests==2.32.3
```

### .env.example

```bash
# Which IdP to use: mock | okta | azuread
IDP=mock

# Okta
OKTA_ORG_URL=https://your-org.okta.com
OKTA_API_TOKEN=changeme

# Azure AD (Client Credentials)
AZURE_TENANT_ID=changeme
AZURE_CLIENT_ID=changeme
AZURE_CLIENT_SECRET=changeme

# Behavior flags
DRY_RUN=true
LOG_LEVEL=INFO
```

### config/mappings.yml

```yaml
# Map HR attributes to groups and roles.
# You can match on department, title, location, or any combination.

# Group rules (strings are friendly names; Okta/Azure clients resolve to real IDs)
groups:
  department:
    Finance: ["Finance-Staff", "Concur-Users"]
    Engineering: ["Engineering-Staff", "GitHub-SSO"]
    Sales: ["Sales-Staff", "Salesforce-Users"]
  title:
    Manager: ["People-Managers"]
  location:
    Remote: ["VPN-Users"]

# Role rules (optional; can be used by apps downstream)
roles:
  department:
    Engineering: ["role:eng.read", "role:eng.deploy"]
  title:
    Director: ["role:system.admin"]
```

### data/new\_hires.csv

```csv
employee_id,first_name,last_name,email,department,title,manager_email,location,start_date,status
1001,Ava,Mensah,ava.mensah@example.com,Engineering,Developer,lead.dev@example.com,Remote,2025-08-01,active
1002,Logan,Adams,logan.adams@example.com,Sales,Account Executive,manager.sales@example.com,NYC,2025-08-05,active
```

### data/terminations.csv

```csv
employee_id,email,end_date,reason
1002,logan.adams@example.com,2025-08-26,Voluntary
```

### lifecycle/**init**.py

```python
__all__ = [
    "__version__",
]

__version__ = "0.1.0"
```

### lifecycle/models.py

```python
from dataclasses import dataclass, field
from typing import Dict, List, Optional

@dataclass
class User:
    employee_id: str
    first_name: str
    last_name: str
    email: str
    department: Optional[str] = None
    title: Optional[str] = None
    manager_email: Optional[str] = None
    location: Optional[str] = None
    start_date: Optional[str] = None
    status: str = "active"
    # computed
    groups: List[str] = field(default_factory=list)
    roles: List[str] = field(default_factory=list)

    @property
    def username(self) -> str:
        return self.email.lower()

    def as_dict(self) -> Dict:
        return {
            "employee_id": self.employee_id,
            "first_name": self.first_name,
            "last_name": self.last_name,
            "email": self.email,
            "department": self.department,
            "title": self.title,
            "manager_email": self.manager_email,
            "location": self.location,
            "start_date": self.start_date,
            "status": self.status,
            "groups": list(self.groups),
            "roles": list(self.roles),
        }
```

### lifecycle/hr.py

```python
import csv
from typing import Iterable, List
from .models import User

REQUIRED_COLUMNS = {
    "employee_id", "first_name", "last_name", "email",
}


def load_users_from_csv(path: str) -> List[User]:
    with open(path, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        missing = REQUIRED_COLUMNS - set(reader.fieldnames or [])
        if missing:
            raise ValueError(f"CSV missing required columns: {missing}")
        users: List[User] = []
        for row in reader:
            users.append(User(
                employee_id=str(row.get("employee_id", "")).strip(),
                first_name=(row.get("first_name", "") or "").strip(),
                last_name=(row.get("last_name", "") or "").strip(),
                email=(row.get("email", "") or "").strip(),
                department=(row.get("department") or None),
                title=(row.get("title") or None),
                manager_email=(row.get("manager_email") or None),
                location=(row.get("location") or None),
                start_date=(row.get("start_date") or None),
                status=(row.get("status") or "active"),
            ))
        return users
```

### lifecycle/mapper.py

```python
from typing import Dict, List
import yaml
from .models import User

class Mapper:
    def __init__(self, mapping_path: str):
        with open(mapping_path, "r", encoding="utf-8") as f:
            self.rules: Dict = yaml.safe_load(f) or {}
        self.group_rules = self.rules.get("groups", {})
        self.role_rules = self.rules.get("roles", {})

    def groups_for(self, user: User) -> List[str]:
        groups: List[str] = []
        # department-based
        dept_map = self.group_rules.get("department", {})
        if user.department and user.department in dept_map:
            groups.extend(dept_map[user.department])
        # title-based
        title_map = self.group_rules.get("title", {})
        if user.title and user.title in title_map:
            groups.extend(title_map[user.title])
        # location-based
        loc_map = self.group_rules.get("location", {})
        if user.location and user.location in loc_map:
            groups.extend(loc_map[user.location])
        return sorted(set(groups))

    def roles_for(self, user: User) -> List[str]:
        roles: List[str] = []
        dept_map = self.role_rules.get("department", {})
        if user.department and user.department in dept_map:
            roles.extend(dept_map[user.department])
        title_map = self.role_rules.get("title", {})
        if user.title and user.title in title_map:
            roles.extend(title_map[user.title])
        return sorted(set(roles))
```

### lifecycle/idp\_base.py

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional
from .models import User

class IdPClient(ABC):
    @abstractmethod
    def ensure_user(self, user: User, apply: bool = False) -> Dict:
        """Create or update a user. Return details including whether it changed."""
        raise NotImplementedError

    @abstractmethod
    def set_groups(self, user: User, groups: List[str], apply: bool = False) -> Dict:
        """Set desired groups for the user (idempotent)."""
        raise NotImplementedError

    @abstractmethod
    def deactivate_user(self, user: User, apply: bool = False) -> Dict:
        """Disable / deprovision a user."""
        raise NotImplementedError

    @abstractmethod
    def get_user(self, username: str) -> Optional[Dict]:
        """Fetch a user object from IdP or None."""
        raise NotImplementedError

    @abstractmethod
    def list_users(self) -> List[Dict]:
        raise NotImplementedError
```

### lifecycle/idps/mock\_idp.py

```python
import json
from pathlib import Path
from typing import Dict, List, Optional
from ..models import User
from ..idp_base import IdPClient

STATE_PATH = Path(__file__).resolve().parents[2] / "state" / "mock_directory.json"


def _load_state() -> Dict:
    if not STATE_PATH.exists():
        STATE_PATH.parent.mkdir(parents=True, exist_ok=True)
        STATE_PATH.write_text(json.dumps({"users": {}, "groups": {}}, indent=2))
    return json.loads(STATE_PATH.read_text())


def _save_state(state: Dict) -> None:
    STATE_PATH.write_text(json.dumps(state, indent=2))


class MockIdP(IdPClient):
    def __init__(self):
        self.state = _load_state()

    def ensure_user(self, user: User, apply: bool = False) -> Dict:
        users = self.state.setdefault("users", {})
        existing = users.get(user.username)
        changed = False
        record = user.as_dict()
        if not existing:
            changed = True
            action = "created"
            if apply:
                users[user.username] = record
        else:
            # Update minimal fields if changed
            diffs = {k: v for k, v in record.items() if existing.get(k) != v and k not in ("groups", "roles")}
            action = "updated" if diffs else "noop"
            changed = bool(diffs)
            if apply and diffs:
                existing.update(diffs)
        if apply:
            _save_state(self.state)
        return {"action": action, "changed": changed}

    def set_groups(self, user: User, groups: List[str], apply: bool = False) -> Dict:
        users = self.state.setdefault("users", {})
        rec = users.get(user.username)
        if not rec:
            return {"action": "skipped", "reason": "user_missing"}
        desired = sorted(set(groups))
        current = sorted(set(rec.get("groups", [])))
        to_add = sorted(set(desired) - set(current))
        to_remove = sorted(set(current) - set(desired))
        if apply:
            rec["groups"] = desired
            _save_state(self.state)
        return {"action": "groups_set", "added": to_add, "removed": to_remove, "changed": bool(to_add or to_remove)}

    def deactivate_user(self, user: User, apply: bool = False) -> Dict:
        users = self.state.setdefault("users", {})
        rec = users.get(user.username)
        if not rec:
            return {"action": "skipped", "reason": "user_missing"}
        changed = rec.get("status") != "inactive"
        if apply and changed:
            rec["status"] = "inactive"
            rec["groups"] = []
            _save_state(self.state)
        return {"action": "deactivated" if changed else "noop", "changed": changed}

    def get_user(self, username: str) -> Optional[Dict]:
        return self.state.get("users", {}).get(username)

    def list_users(self) -> List[Dict]:
        return list(self.state.get("users", {}).values())
```

### lifecycle/idps/okta\_idp.py

```python
"""
Okta client skeleton with guidance for real API calls.
- Uses token auth in header: Authorization: SSWS <token>
- Key endpoints: /api/v1/users, /api/v1/groups, /api/v1/users/{id}
Add retries for 429 with exponential backoff respecting Okta-Rate-Limit headers.
"""
from typing import Dict, List, Optional
import os, time
import requests
from ..models import User
from ..idp_base import IdPClient

class OktaIdP(IdPClient):
    def __init__(self):
        self.base = os.getenv("OKTA_ORG_URL", "").rstrip("/")
        self.token = os.getenv("OKTA_API_TOKEN", "")
        self.session = requests.Session()
        self.session.headers.update({"Authorization": f"SSWS {self.token}", "Accept": "application/json"})

    def _req(self, method: str, path: str, **kw) -> requests.Response:
        url = f"{self.base}{path}"
        backoff = 1.0
        for attempt in range(6):
            r = self.session.request(method, url, timeout=30, **kw)
            if r.status_code != 429:
                r.raise_for_status()
                return r
            # Respect rate-limiting
            reset = float(r.headers.get("X-Rate-Limit-Reset", 0))
            now = time.time()
            sleep_for = max(reset - now, backoff)
            time.sleep(min(sleep_for, 10))
            backoff = min(backoff * 2, 10)
        r.raise_for_status()
        return r

    def ensure_user(self, user: User, apply: bool = False) -> Dict:
        # Minimal implementation: lookup by login, create if missing; update profile if present.
        # NOTE: Fill in production profile schema, groups handled separately.
        found = self._find_user(user.username)
        if not found:
            action = "created"
            if apply:
                payload = {
                    "profile": {
                        "firstName": user.first_name,
                        "lastName": user.last_name,
                        "email": user.email,
                        "login": user.email,
                        "department": user.department,
                        "title": user.title,
                        "manager": user.manager_email,
                        "city": user.location,
                    },
                    "credentials": {"password": {"value": "TempP@ssw0rd123!"}},
                }
                self._req("POST", "/api/v1/users?activate=true", json=payload)
            return {"action": action, "changed": True}
        else:
            # Update basic attributes if changed (simplified)
            action = "updated"
            if apply:
                user_id = found["id"]
                profile = found.get("profile", {})
                patch = {
                    "profile": {
                        **profile,
                        "firstName": user.first_name,
                        "lastName": user.last_name,
                        "email": user.email,
                        "login": user.email,
                        "department": user.department,
                        "title": user.title,
                        "manager": user.manager_email,
                        "city": user.location,
                    }
                }
                self._req("POST", f"/api/v1/users/{user_id}", json=patch)
            return {"action": action, "changed": True}

    def set_groups(self, user: User, groups: List[str], apply: bool = False) -> Dict:
        # Resolve friendly group names to IDs, then ensure memberships.
        # Left for implementation when connected to real tenant.
        return {"action": "noop", "changed": False, "note": "implement group resolution & membership APIs"}

    def deactivate_user(self, user: User, apply: bool = False) -> Dict:
        found = self._find_user(user.username)
        if not found:
            return {"action": "skipped", "reason": "user_missing"}
        if apply:
            user_id = found["id"]
            self._req("POST", f"/api/v1/users/{user_id}/lifecycle/deactivate")
        return {"action": "deactivated", "changed": True}

    def get_user(self, username: str) -> Optional[Dict]:
        return self._find_user(username)

    def list_users(self) -> List[Dict]:
        r = self._req("GET", "/api/v1/users")
        return r.json()

    def _find_user(self, login: str) -> Optional[Dict]:
        if not login:
            return None
        r = self._req("GET", f"/api/v1/users/{login}")
        return r.json() if r.status_code == 200 else None
```

### lifecycle/idps/azuread\_idp.py

```python
"""
Azure AD client skeleton using Client Credentials.
- Acquire token: POST to https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token
- Graph endpoints: https://graph.microsoft.com/v1.0/users, /groups, /users/{id}
Add retries for 429/503; respect Retry-After.
"""
from typing import Dict, List, Optional
import os, time
import requests
from ..models import User
from ..idp_base import IdPClient

class AzureADIdP(IdPClient):
    def __init__(self):
        self.tenant = os.getenv("AZURE_TENANT_ID", "")
        self.client_id = os.getenv("AZURE_CLIENT_ID", "")
        self.client_secret = os.getenv("AZURE_CLIENT_SECRET", "")
        self.session = requests.Session()
        self.token = None

    def _auth(self):
        if self.token:
            return
        url = f"https://login.microsoftonline.com/{self.tenant}/oauth2/v2.0/token"
        data = {
            "client_id": self.client_id,
            "client_secret": self.client_secret,
            "grant_type": "client_credentials",
            "scope": "https://graph.microsoft.com/.default",
        }
        r = requests.post(url, data=data, timeout=30)
        r.raise_for_status()
        self.token = r.json()["access_token"]
        self.session.headers.update({"Authorization": f"Bearer {self.token}"})

    def _req(self, method: str, url: str, **kw) -> requests.Response:
        self._auth()
        backoff = 1.0
        for attempt in range(6):
            r = self.session.request(method, url, timeout=30, **kw)
            if r.status_code not in (429, 503):
                r.raise_for_status()
                return r
            ra = r.headers.get("Retry-After")
            sleep_for = float(ra) if ra else backoff
            time.sleep(min(sleep_for, 10))
            backoff = min(backoff * 2, 10)
        r.raise_for_status()
        return r

    def ensure_user(self, user: User, apply: bool = False) -> Dict:
        found = self._find_user(user.username)
        if not found:
            action = "created"
            if apply:
                payload = {
                    "accountEnabled": True,
                    "displayName": f"{user.first_name} {user.last_name}",
                    "mailNickname": user.email.split("@")[0],
                    "userPrincipalName": user.email,
                    "passwordProfile": {"forceChangePasswordNextSignIn": True, "password": "TempP@ssw0rd123!"},
                    "jobTitle": user.title,
                    "department": user.department,
                    "city": user.location,
                }
                self._req("POST", "https://graph.microsoft.com/v1.0/users", json=payload)
            return {"action": action, "changed": True}
        else:
            action = "updated"
            if apply:
                user_id = found["id"]
                patch = {"jobTitle": user.title, "department": user.department, "city": user.location}
                self._req("PATCH", f"https://graph.microsoft.com/v1.0/users/{user_id}", json=patch)
            return {"action": action, "changed": True}

    def set_groups(self, user: User, groups: List[str], apply: bool = False) -> Dict:
        # Resolve names -> IDs and ensure membership. Left as exercise for real tenant.
        return {"action": "noop", "changed": False, "note": "implement /groups & /members endpoints"}

    def deactivate_user(self, user: User, apply: bool = False) -> Dict:
        found = self._find_user(user.username)
        if not found:
            return {"action": "skipped", "reason": "user_missing"}
        if apply:
            user_id = found["id"]
            self._req("PATCH", f"https://graph.microsoft.com/v1.0/users/{user_id}", json={"accountEnabled": False})
        return {"action": "deactivated", "changed": True}

    def get_user(self, username: str) -> Optional[Dict]:
        return self._find_user(username)

    def list_users(self) -> List[Dict]:
        r = self._req("GET", "https://graph.microsoft.com/v1.0/users")
        return r.json().get("value", [])

    def _find_user(self, upn: str) -> Optional[Dict]:
        if not upn:
            return None
        url = f"https://graph.microsoft.com/v1.0/users/{upn}"
        r = self._req("GET", url)
        return r.json() if r.status_code == 200 else None
```

### lifecycle/engine.py

```python
import os
from typing import List
from .models import User
from .mapper import Mapper
from .idp_base import IdPClient
from .idps.mock_idp import MockIdP

try:
    from .idps.okta_idp import OktaIdP  # type: ignore
except Exception:  # pragma: no cover
    OktaIdP = None  # type: ignore

try:
    from .idps.azuread_idp import AzureADIdP  # type: ignore
except Exception:  # pragma: no cover
    AzureADIdP = None  # type: ignore


def get_idp(name: str) -> IdPClient:
    name = (name or os.getenv("IDP", "mock")).lower()
    if name == "mock":
        return MockIdP()
    if name == "okta" and OktaIdP:
        return OktaIdP()
    if name == "azuread" and AzureADIdP:
        return AzureADIdP()
    raise ValueError(f"Unsupported or unavailable IdP: {name}")


def sync_users(users: List[User], mapper: Mapper, idp: IdPClient, apply: bool = False) -> List[dict]:
    results = []
    for u in users:
        u.groups = mapper.groups_for(u)
        u.roles = mapper.roles_for(u)
        res1 = idp.ensure_user(u, apply=apply)
        res2 = idp.set_groups(u, u.groups, apply=apply)
        results.append({"user": u.email, **res1, **{f"groups_{k}": v for k, v in res2.items()}})
    return results


def offboard_users(users: List[User], idp: IdPClient, apply: bool = False) -> List[dict]:
    results = []
    for u in users:
        res = idp.deactivate_user(u, apply=apply)
        results.append({"user": u.email, **res})
    return results


def audit(idp: IdPClient) -> List[dict]:
    # Simple audit: list active users and their groups
    return idp.list_users()
```

### lifecycle/cli.py

```python
import argparse
import os
import json
from dotenv import load_dotenv
from .hr import load_users_from_csv
from .mapper import Mapper
from .engine import get_idp, sync_users, offboard_users, audit

load_dotenv()


def main():
    parser = argparse.ArgumentParser(description="Identity Lifecycle Automation CLI")
    sub = parser.add_subparsers(dest="cmd", required=True)

    p_sync = sub.add_parser("sync", help="Onboard/update users from HR source")
    p_sync.add_argument("--source", required=True, help="Path to HR CSV with new hires/updates")
    p_sync.add_argument("--mapping", required=True, help="Path to group/role mapping YAML")
    p_sync.add_argument("--idp", default=os.getenv("IDP", "mock"))
    p_sync.add_argument("--dry-run", action="store_true")
    p_sync.add_argument("--apply", action="store_true")

    p_off = sub.add_parser("offboard", help="Deactivate users from HR terminations CSV")
    p_off.add_argument("--source", required=True)
    p_off.add_argument("--idp", default=os.getenv("IDP", "mock"))
    p_off.add_argument("--dry-run", action="store_true")
    p_off.add_argument("--apply", action="store_true")

    p_audit = sub.add_parser("audit", help="Dump simple audit of IdP state")
    p_audit.add_argument("--idp", default=os.getenv("IDP", "mock"))

    args = parser.parse_args()

    if args.cmd == "sync":
        users = load_users_from_csv(args.source)
        mapper = Mapper(args.mapping)
        idp = get_idp(args.idp)
        apply = args.apply and not args.dry_run and os.getenv("DRY_RUN", "false").lower() != "true"
        results = sync_users(users, mapper, idp, apply=apply)
        print(json.dumps(results, indent=2))

    elif args.cmd == "offboard":
        users = load_users_from_csv(args.source)
        idp = get_idp(args.idp)
        apply = args.apply and not args.dry_run and os.getenv("DRY_RUN", "false").lower() != "true"
        results = offboard_users(users, idp, apply=apply)
        print(json.dumps(results, indent=2))

    elif args.cmd == "audit":
        idp = get_idp(args.idp)
        results = audit(idp)
        print(json.dumps(results, indent=2))

if __name__ == "__main__":
    main()
```

### lifecycle/idps/**init**.py

```python
# namespace package for IdP providers
```

### state/mock\_directory.json

```json
{
  "users": {},
  "groups": {}
}
```

### tests/test\_mapper.py

```python
from lifecycle.mapper import Mapper
from lifecycle.models import User


def test_groups_and_roles(tmp_path):
    mapping = tmp_path / "map.yml"
    mapping.write_text(
        """
        groups:
          department:
            Engineering: ["Engineering-Staff", "GitHub-SSO"]
          title:
            Manager: ["People-Managers"]
        roles:
          department:
            Engineering: ["role:eng.read"]
        """
    )
    m = Mapper(str(mapping))
    u = User(employee_id="1", first_name="A", last_name="B", email="a@b.com", department="Engineering", title="Manager")
    assert m.groups_for(u) == ["Engineering-Staff", "GitHub-SSO", "People-Managers"]
    assert m.roles_for(u) == ["role:eng.read"]
```

### tests/test\_engine.py

```python
from lifecycle.engine import sync_users
from lifecycle.mapper import Mapper
from lifecycle.models import User
from lifecycle.idps.mock_idp import MockIdP


def test_sync_idempotent(tmp_path):
    # Write mapping
    mapping = tmp_path / "map.yml"
    mapping.write_text(
        """
        groups:
          department:
            Sales: ["Sales-Staff"]
        """
    )
    mapper = Mapper(str(mapping))
    idp = MockIdP()
    u = User(employee_id="100", first_name="L", last_name="A", email="la@example.com", department="Sales")

    # First run creates & assigns
    r1 = sync_users([u], mapper, idp, apply=True)
    # Second run should be mostly no-ops for groups
    r2 = sync_users([u], mapper, idp, apply=True)

    assert r1[0]["changed"] is True
    assert r2[0]["changed"] in (True, False)  # update may or may not be needed
```

### .github/workflows/ci.yml

```yaml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest
      - name: Run tests
        run: pytest -q
```

---

## 🧪 Example Runs

* **Dry-run sync** (no state changes): shows planned creates/updates and group diffs.
* **Apply sync**: persists to `state/mock_directory.json`.
* **Offboard**: deactivates and strips groups.
* **Audit**: dumps current directory snapshot.

---

## 📝 Notes & Next Steps

* Expand Okta/Azure clients to resolve group names → IDs, then add/remove memberships.
* Add **rate-limit aware** batch processing (e.g., sleep between pages, exponential backoff already scaffolded).
* Add **CSV exports** for evidence (who changed, when, what groups assigned) to hand auditors.
* Plug in **API HR source** (Workday/Bamboo/UKG) by adding a `load_users_from_api()` in `hr.py`.
* Add **notifications** (email/Slack) for failed records.

---

## 🧰 How to Run in GitHub

* Push this repo to GitHub.
* CI runs tests on PRs and pushes.
* Add a **GitHub Actions workflow** for scheduled audits (cron) if you want daily compliance reports.

```yaml
# .github/workflows/audit-nightly.yml
name: Audit Nightly
on:
  schedule: [{ cron: '0 2 * * *' }]
  workflow_dispatch: {}
jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      - run: |
          pip install -r requirements.txt
          python -m lifecycle.cli audit --idp mock > audit.json
      - uses: actions/upload-artifact@v4
        with:
          name: audit-json
          path: audit.json
```

---

## 📜 License

MIT (adjust as needed).
